#!/usr/bin/perl -w
######################################################################
# Author: Carlos Puchol <cpg at amahi dot org>
# This code is property and copyright of Amahi Inc.
# It's licensed under the GNU GPL V2 License
######################################################################

use strict;
use DBI();
use Getopt::Std;
use LWP::Simple;
use URI::Escape;
use POSIX qw(strftime);
use POSIX qw(mkfifo);
use IO::Handle;
use IO::File;
use Socket;

# these variables can be customized in /etc/hda-ctl.conf
# to set default settings in the conf file, you can do things like:
# $DEVICE = "eth0";
# it's full perl, so do NOT break it!
# note that if these settings are in the database, those always take priority when the program starts
our ($DEVICE, $NETMASK_SIZE, $NET_START, $DYN_LO, $DYN_HI, $USE_OPENDNS_SECONDARY);

my $conf_file = "/etc/hda-ctl.conf";
do $conf_file if -e $conf_file;

# pick up the default route device
my $default_dev = `ip route | awk '/^default/ { printf \$5 }'`;

my $device = $DEVICE || $default_dev || "eth0";

# To enable DNS resolution secondary via OpenDNS,
# set the line below to 1
my $use_opendns_secondary = 0;

# change defaults here, though, if they are are in the database as settings, those always take priority
my $default_netmask_size = $NETMASK_SIZE || "24";
my $default_net_start = $NET_START || "0";
my $default_dyn_lo = $DYN_LO || "100";
my $default_dyn_hi = $DYN_HI || "254";

my $version = "4.2.3";

my $DATABASE_NAME = "hda_production";
my $DATABASE_USER = "amahihda";
my $DATABASE_PASSWORD = "AmahiHDARulez";

our($opt_d, $opt_h);
getopts('dh');

my $pidfile = "/var/run/hda-ctl.pid";
my $period = 600; # run period, in seconds
my $cmdfile = "/var/run/hda-ctl/notify";

my $platform = "unknown";
my $named_user;
my $named_service;
my $named_dir;
my $network_service;
my $dhcp_service;

## process args
my $programd  = $0; 
$programd =~ s%^.*/%%;
my $program   = $programd;
$program  =~ s/d$//;
my $now = time;

my $caught_hup  = 0;
my $caught_term = 0;
my $caught_usr1 = 0;
$SIG{'HUP'}    = sub { $caught_hup  = 1; };
$SIG{'TERM'}   = sub { $caught_term = 1; };
$SIG{'USR1'}   = sub { $caught_usr1 = 1; };

my $CMDFIFO;

# global database handle for both functions below
my $dbh;
my %settings;
my @host = ();
my %named_options;

my $file_named = "named.conf";
my $file_n2a = "hda-n2a.conf";
my $file_a2n = "hda-a2n.conf";
my $file_hda = "hda.conf"; # "void" file
my $file_dhcpd = "dhcpd.conf";
my $file_resolv = "resolv.conf";
my $file_ifcfg = "ifcfg-$device";

my $ifcfg_idx = 1;
my $dump_mode = 0;

# reverse ip address
sub reverse_net {
	return (join (".", reverse (split(/\./, shift)))) . ".in-addr.arpa";
}

sub pipecmd {
	my $cmd   = shift;
	my $stdin = join("\n", @_);
	my $ok    = 0;

	# remove trailing newlines
	1 while chomp($stdin);

	# override when debugging.
	$cmd = "| $cmd";

	# execute the command.
	local *FD;
	if (! open(FD, $cmd)) {
		printf STDERR "$program: cannot execute command %s.\n", $cmd;
	} elsif ($stdin && (! print FD "$stdin\n")) {
		printf STDERR "$program: failed writting to %s.\n", $cmd;
		close(FD);
	} elsif (! close(FD)) {
		# printf STDERR "$program: failed closing %s.($@)\n", $cmd;
	} elsif ($?) {
		printf STDERR "$program: failed %s. ($@)\n", $cmd;
	} else {
		$ok = 1;
	}
	return $ok;
}

sub log {
	my $facility = "daemon";
	my $priority = "notice";

	return pipecmd("logger -p$facility.$priority -t${program}\[$$\]", @_);
}

sub logdie {
	my $arg = shift;
	my $facility = "daemon";
	my $priority = "notice";

	return pipecmd("logger -p$facility.$priority -t${program}\[$arg - exiting\]", @_);
	exit -1;
}

sub get_named_settings {
	open(my $named, "<", "/etc/sysconfig/named") or return;

	while (<$named>) {
		next if /^\s*#/; # skip options
		if (/(\w+)\s*=\s*"?(.+?)"?\s*$/) {
			my $name = $1;
			my $value = $2;
			chomp $value;
			$named_options {$name} = $value;
		}
	}

	close ($named);
}

sub check_db_sanity {

	return 0 unless $dbh;

	my $sth = $dbh->prepare("SELECT value FROM settings WHERE name = 'api-key'");
	$sth->execute();

	my @row = ();
	@row = $sth->fetchrow_array;
	my $value = $row[0];
	$sth->finish();

	return 1 if (length($value) == 40);
	return 0;
}

sub get_db_settings {

	my $sth = $dbh->prepare("SELECT Name, Value FROM settings");
	$sth->execute();

	my @row = ();
	while (@row = $sth->fetchrow_array) {
		my $name = $row[0];
		my $value = $row[1];
		$settings {$name} = $value;
	}
	$sth->finish();

	# set defaults for new network stuff
	$settings{'netmask_size'} = $settings{'netmask_size'} || $default_netmask_size;
	$settings{'net_start'} = $settings{'net_start'} || $default_net_start;
	$settings{'dyn_lo'} = $settings{'dyn_lo'} || $default_dyn_lo;
	$settings{'dyn_hi'} = $settings{'dyn_hi'} || $default_dyn_hi;
}

sub db_connect {

	# wait forever until the DB is up
	while (1) {
                $dbh = DBI->connect("DBI:mysql:database=$DATABASE_NAME;host=localhost",
                                $DATABASE_USER, $DATABASE_PASSWORD);
		if ($dbh && &check_db_sanity()) {
			return;
		}
		sleep(60);
	}
}

sub db_disconnect {
	$dbh->disconnect();
}

sub print_named_conf {

	open(my $hda, ">", $file_named);

	my $domain = $settings{'domain'};
	my $net = $settings{'net'};
	my $reverse_net = &reverse_net($settings{'net'});
	my $full_net = $net . "." . $settings{'net_start'};
	my $netmask_size = $settings{'netmask_size'};
	my $gw = $net . "." . $settings{'gateway'};
	my $self = $net . "." . $settings{'self-address'};
	my $dns1 = $self;
	my $dyn_lo = $net . "." . $settings{'dyn_lo'};
	my $dyn_hi = $net . "." . $settings{'dyn_hi'};
	my $extdns1 = $gw;
	my $extdns2 = "";

	if (defined($settings{'external-dns1'})) {
		$extdns1 = $settings{'external-dns1'};
	} elsif (defined($settings{'dns1'})) {
		$extdns1 = $settings{'dns1'};
	}

	if (defined($settings{'external-dns2'})) {
		$extdns2 = $settings{'external-dns2'};
		$extdns2 .= ";";
	} elsif (defined($settings{'dns1'})) {
		$extdns2 = $settings{'dns2'};
		$extdns2 .= ";";
	}

	printf $hda "# automatically generated file by hda-ctl\n";
	printf $hda "options {\n";
	printf $hda "\tlisten-on-v6 port 53 { ::1; };\n";
	printf $hda "\tdirectory \"/var/named\";\n";
	printf $hda "\tdump-file \"/var/named/data/cache_dump.db\";\n";
	printf $hda "\tstatistics-file \"/var/named/data/named_stats.txt\";\n";
	printf $hda "\tmemstatistics-file \"/var/named/data/named_mem_stats.txt\";\n";
	printf $hda "\tforward only;\n";
	printf $hda "\tforwarders { %s; %s };\n", $extdns1, $extdns2;
	printf $hda "\tlisten-on port 53 { %s; 127.0.0.1; };\n", $self;
	printf $hda "\tallow-query { trusted; };\n";
	printf $hda "};\n";

	printf $hda "acl \"trusted\" {\n";
	printf $hda "\tlocalhost;\n";
	printf $hda "\t10.8.0.0/16;\n";
	printf $hda "\t%s/%s;\n", $full_net, $netmask_size;
	printf $hda "};\n";

	printf $hda "logging {\n";
	printf $hda "\tchannel default_debug {\n";
	printf $hda "\t\tfile \"data/named.run\";\n";
	printf $hda "\t\tseverity dynamic;\n";
	printf $hda "\t};\n";
	printf $hda "};\n";

	# FIXME: this logging is temporary to log sites.
	# printf $hda "\tchannel hda-dns-logger {\n";
	# printf $hda "\t\tfile \"data/hda-logger.log\";\n";
	# printf $hda "\t\tprint-time yes;\n";
	# printf $hda "\t\tprint-category yes;\n";
	# printf $hda "\t\tseverity debug 3;\n";
	# printf $hda "\t};\n";
	# printf $hda "\tcategory queries { hda-dns-logger; };\n";
	# printf $hda "\tcategory security { hda-dns-logger; };\n";
	# printf $hda "\tcategory resolver { hda-dns-logger; };\n";
	# printf $hda "\tcategory client { hda-dns-logger; };\n";
	# printf $hda "};\n";

        printf $hda "key \"ddnskey\" {\n";
        printf $hda "\talgorithm hmac-md5;\n";
        printf $hda "\tsecret \"%s\";\n", "8zaPJsiw9tOh2JFv4xiArw==";
        printf $hda "};\n\n";

        printf $hda "view \"internal\" {\n";
        printf $hda "	match-clients		{ trusted; };\n";
        printf $hda "	match-destinations	{ trusted; };\n\n";


	printf $hda "zone \"%s\" IN {\n", $domain;
        printf $hda "\ttype master;\n";
        printf $hda "\tnotify no;\n";
        printf $hda "\tfile \"dynamic/%s\";\n", $file_n2a;
        printf $hda "\tallow-update { key ddnskey; };\n";
        printf $hda "\tcheck-names ignore;\n";
	printf $hda "};\n\n";

	# FIXME: this needs to be derived from the $net!!
	printf $hda "zone \"%s\" IN {\n", &reverse_net($net);
       	printf $hda "\ttype master;\n";
       	printf $hda "\tnotify no;\n";
       	printf $hda "\tfile \"dynamic/%s\";\n", $file_a2n;
        printf $hda "\tallow-update { key ddnskey; };\n";
        printf $hda "\tcheck-names ignore;\n";
	printf $hda "};\n\n";

	printf $hda "\n";
	printf $hda "\n# NOTE, you can create a file /etc/named.conf.local and it will be automatically included here!\n";
	printf $hda "# WARNING - you better not break the format though!\n";
        if (-e '/etc/named.conf.local') {
		printf $hda "include \"/etc/named.conf.local\";\n";
        }
	printf $hda "};\n\n";
}

sub print_void_info {
	my $domain = shift;
	my $void_host = shift;

	open(my $void, ">", $file_hda);

	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime();
	$year -= 100;
	$year = 10 if $year < 10; # needed e.g. if the system has a bad clock
	my $serial = sprintf("%02d%02d%02d%02d%02d", $year, $mon, $mday, $hour, $min);

	printf $void "\$TTL    86400\n";
	printf $void "@ IN SOA hda.%s. root.%s. (\n", $domain, $domain;
        printf $void "\t%s ; Serial\n", $serial;
        printf $void "\t28800   ; Refresh\n";
        printf $void "\t14400   ; Retry\n";
        printf $void "\t3600000 ; Expire\n";
        printf $void "\t86400 ) ; Minimum\n";
	printf $void "\t\tIN NS hda.%s.\n", $void_host;
	printf $void "\t\tIN A %s\n", $void_host;
	printf $void "*\tIN A %s\n", $void_host;
	printf $void "\n";

	close $void;
}

sub fill_hosts_table {

	my $first_addr = shift;
	my $last_addr = shift;

	foreach my $i ($first_addr .. $last_addr) {
		$host[$i] = sprintf ("h%03d", $i);
	}

	my $sth = $dbh->prepare("SELECT Host, Address FROM hosts");
	$sth->execute();

	my @row = ();
	while (@row = $sth->fetchrow_array) {
		my $name = $row[0];
		my $address = int($row[1]);
		if ($address > 0 && $address < 255) {
			$host[$address] = $name;
		}
	}

	# Hard-code the hostname for the HDA to 'hda'
	$host[int($settings{'self-address'})] = "hda";

	$sth->finish();
}

sub print_aliases {
	my $name2addr = shift;


	my $sth = $dbh->prepare("SELECT name, address FROM dns_aliases");
	$sth->execute();

	my @row = ();
	while (@row = $sth->fetchrow_array) {
		my $alias = $row[0];
		# address can be of three forms:
		# '' -> the alias maps to the self-address ip
		# '<int>' -> the alias maps to the 1-255 address
		# 'some.full.ip.address' -> the alias maps to that address
		my $address = $row[1];
		# if empty, point to the self-address host
		if ($address =~ /^\s*$/) {
			my $default_alias_ip = $settings{'net'} . "." . $settings{'self-address'};
			printf $name2addr "%s\t\tA\t%s\n", $alias, $default_alias_ip;
		} else {
			# if it has just an bunch of digits check if it's a simple ip
			if ($address =~ /^\s*\d+\s*$/) {
				my $ip = int($address);
				if (($ip > 0) && ($ip < 255)) {
					my $full_ip = $settings{'net'} . "." . $ip;
					printf $name2addr "%s\t\tA\t%s\n", $alias, $full_ip;
				} else {
					&log ("skipping alias '$alias' for address '$address' (too large)")
				}
			} else {
				# else check if it's in the form
				# of an address
				if ($address =~ /^\s*\d+\.\d+\.\d+\.\d+\s*$/) {
					# FIXME: this should have some more checking.
					printf $name2addr "%s\t\tA\t%s\n", $alias, $address;
				} else {
					# else assume is a cname
					&log ("skipping alias '$alias' for address '$address' (the latter does not parse as an ip address)");
					# FIXME - this has the potential to generate
					# bad config files. so it's disabled.
					# printf $name2addr "%s\t\tCNAME\t%s\n", $alias, $address;
				}
			}
		}
	}
	$sth->finish();
}

sub print_n2a_info {
	my $serial = shift;
	my $first_addr = shift;
	my $last_addr = shift;

	open(my $name2addr, ">", $file_n2a);

	my $domain = $settings{'domain'};
	my $net = $settings{'net'};

	printf $name2addr "\$TTL    86400\n";
	printf $name2addr "@ IN SOA hda.%s. root.%s. (\n", $domain, $domain;
        printf $name2addr "\t%s ; Serial\n", $serial;
        printf $name2addr "\t28800   ; Refresh\n";
        printf $name2addr "\t14400   ; Retry\n";
        printf $name2addr "\t3600000 ; Expire\n";
        printf $name2addr "\t86400 ) ; Minimum\n";
	printf $name2addr "\t\tIN NS hda.%s.\n", $domain;
	printf $name2addr "\t\tIN MX 10 hda.%s.\n", $domain;
	printf $name2addr "*\tIN MX 10 hda.%s.\n", $domain;
	printf $name2addr "\n";

	foreach my $i ($first_addr .. $last_addr) {
		printf $name2addr "%s\t\tA\t%s.%d\n",
			$host[$i], $net, $i;
	}

	&print_aliases ($name2addr);

	close $name2addr;
}

sub print_a2n_info {
	my $serial = shift;
	my $first_addr = shift;
	my $last_addr = shift;

	open(my $addr2name, ">", $file_a2n);

	my $domain = $settings{'domain'};
	my $net = $settings{'net'};

	printf $addr2name "\$TTL    86400\n";
	printf $addr2name "@ IN SOA hda.%s. root.%s. (\n", $domain, $domain;
        printf $addr2name "\t%s ; Serial\n", $serial;
        printf $addr2name "\t28800   ; Refresh\n";
        printf $addr2name "\t14400   ; Retry\n";
        printf $addr2name "\t3600000 ; Expire\n";
        printf $addr2name "\t86400 ) ; Minimum\n";
	printf $addr2name "\t\tIN NS hda.%s.\n", $domain;
	printf $addr2name "\t\tIN MX 10 hda.%s.\n", $domain;
	printf $addr2name "*\tIN MX 10 hda.%s.\n", $domain;
	printf $addr2name "\n";

	foreach my $i ($first_addr .. $last_addr) {
		printf $addr2name "%d\tPTR\t%s.%s.\n",
			$i, $host[$i], $domain;
	}

	close $addr2name;
}

sub print_domain_info {

	my $domain = $settings{'domain'};
	my $net = $settings{'net'};
	my $rev_net = &reverse_net($net);
	my $void_host = $net . "." . $settings{'self-address'};
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = gmtime();
	$year -= 100;
	$year = 10 if $year < 10; # needed e.g. if the system has a bad clock
	my $serial = sprintf("%02d%02d%02d%02d%02d", $year, $mon, $mday, $hour, $min);

	my $first_addr = $settings{'net_start'} + 1;
	my $last_addr = $first_addr + 2 ** (32 - $settings{'netmask_size'}) - 3;

	my $freeze1 = sprintf("rndc freeze %s", $domain);
	my $freeze2 = sprintf("rndc freeze %s", $rev_net);
	my $thaw1 = sprintf("rndc thaw %s", $domain);
	my $thaw2 = sprintf("rndc thaw %s", $rev_net);

	# FIXME: this needs some error checking!
	if (!$dump_mode) { system ($freeze1); system ($freeze2); }
	&fill_hosts_table($first_addr, $last_addr);
	&print_n2a_info ($serial, $first_addr, $last_addr);
	&print_a2n_info ($serial, $first_addr, $last_addr);
	&print_void_info ($domain, $void_host);
	# FIXME: this needs some error checking as well!
	if (!$dump_mode) { system ($thaw1); system ($thaw2); }
}

sub mv {
	my $from = shift;
	my $to = shift;

	if ($dump_mode) {
		printf ("file " . $from . " would be going to " . $to . "/\n");
		return;
	}

	# &log ("moving " . $from . " to " . $to . "/\n");
	system ("mv " . $from . " " . $to . "/");
}

sub move_files {

	my ($l, $p, $uid, $gid) = getpwnam($named_user);
	chown $uid, $gid, $file_named, $file_hda, $file_n2a, $file_a2n;

	my $prefix = "";
	if (defined($named_options{'ROOTDIR'})) {
		$prefix = $named_options{'ROOTDIR'};
	}

	# FIXME: error checking!
	&mv ($file_named, $prefix . "$named_dir");
	&mv ($file_hda, $prefix . "/var/named");
	&mv ($file_n2a, $prefix . "/var/named/dynamic");
	&mv ($file_a2n, $prefix . "/var/named/dynamic");

	# no prefix for dhcpd conf file
	my $dhcp_path = "/etc/dhcp";

	&mv ($file_dhcpd, $dhcp_path);
	# &mv ($file_resolv, "/etc");
}


###   end of named settings

###   begin of dhcpd settings


sub print_one_host {
	my $file = shift;
	my $host = shift;
	my $mac = shift;
	my $address = shift;
	my $domain = shift;

	print $file "host $host {\n" .
              "\thardware ethernet $mac;\n" .
              "\tfixed-address $host.$domain;\n" .
	      "\toption host-name \"$host\";\n" .
              "}\n";
}

sub print_dhcp_conf_hosts {
	my $file = shift;

	my $sth = $dbh->prepare("SELECT Host, MAC, Address FROM hosts order by Host");
	$sth->execute();

	my @row = ();
	while ( @row = $sth->fetchrow_array ) {
		&print_one_host ($file, $row[0], $row[1], $row[2], $settings {'domain'});
	}
	$sth->finish();
}


# print_fedora_network and print_debian_network may be merged
sub print_fedora_network {

	my $netmask = $settings{'netmask'};
	my $self = $settings{'self-address'};
	my $domain = $settings{'domain'};
	my $net = $settings{'net'};
	my $nick = $settings{'nick'};
	my $id = $settings{'hda-id'};
	my $gw = $settings{'gateway'};
	my $dns1 = $settings{'external-dns1'};
	my $dns2 = $settings{'external-dns2'};

	my $prefix = "/etc/sysconfig/network-scripts";
	my $ifcfg = "$prefix/$file_ifcfg";

	my $temp_fh = IO::File->new_tmpfile or &logdie("cannot open a temporary file: $!");
	open (my $IFCFG, "< $ifcfg") or &logdie("cannot open '$ifcfg' for reading: $!");
	while (<$IFCFG>) {
		next if /IPADDR|NETMASK|GATEWAY|DNS1|DNS2|SEARCH|DOMAIN|BOOTPROTO|NM_CONTROLLED|ONBOOT/;
		next if /generated by hda-ctl/;
		$temp_fh->syswrite($_);
	}
	close $IFCFG;

	my $ifcfg_fh=IO::File->new("> $ifcfg") or &logdie("cannot open file $ifcfg: $!");

	# Write out the new file from the temporary file handle
	$temp_fh->sysseek(0, 0);
	my $data = '';
	my $header = "# generated by hda-ctl on " . strftime("%Y-%m-%d %H:%M:%S", localtime) . " / " . $ifcfg_idx++;
	$ifcfg_fh->syswrite($data) while $temp_fh->sysread($data, 1024);
	$ifcfg_fh->syswrite("IPADDR=$net.$self\nNETMASK=$netmask\nGATEWAY=$net.$gw\nDNS1=$net.$self\nDNS2=$net.$self\n");
	$ifcfg_fh->syswrite("SEARCH=$domain\nDOMAIN=$domain\nBOOTPROTO=none\nNM_CONTROLLED=no\nONBOOT=yes\n$header\n");
	$ifcfg_fh->close;
	$temp_fh->close;

	# move the old one out of the way - confuses some scripts
	# and the network configuration program!
	#system("mv $ifcfg$suffix /tmp");
	system("rm /etc/sysconfig/networking/devices/$file_ifcfg /etc/sysconfig/networking/profiles/default/$file_ifcfg");
	system("ln $prefix/$file_ifcfg /etc/sysconfig/networking/devices/$file_ifcfg");
	system("ln $prefix/$file_ifcfg /etc/sysconfig/networking/profiles/default/$file_ifcfg");

	my $rslv = "/etc/resolv.conf";
	open (my $RSLV, "> $rslv") or &logdie("cannot open '$rslv' for writing: $!");
	printf $RSLV "search $domain\n";
	printf $RSLV "nameserver $net.$self\n";
	close $RSLV;

	# ensure it's readable!
	chmod 0644, $rslv;
}

sub print_debian_network {

	my $netmask = $settings{'netmask'};
	my $self = $settings{'self-address'};
	my $domain = $settings{'domain'};
	my $net = $settings{'net'};
	my $nick = $settings{'nick'};
	my $id = $settings{'hda-id'};
	my $gw = $settings{'gateway'};
	my $dns1 = $settings{'external-dns1'};
	my $dns2 = $settings{'external-dns2'};

        my $ifcfg = "/etc/network/interfaces";

	my $ifcfg_fh=IO::File->new("> $ifcfg") or &logdie("cannot open file $ifcfg: $!");
	$ifcfg_fh->sysseek(0, 0);

	my $header = "# Generated by hda-ctl on " . strftime("%Y-%m-%d %H:%M:%S", localtime) . " / " . $ifcfg_idx++;
        $ifcfg_fh->syswrite("$header\n" .
                            "auto lo $device\n\n" .
                            "iface lo inet loopback\n\n" .
                            "iface $device inet static\n" .
                            "     address $net.$self\n" .
                            "     netmask $netmask\n" .
                            "     gateway $net.$gw\n" .
                            "     dns-nameservers $net.$self\n" .
                            "     dns-search $domain\n");
	$ifcfg_fh->close;

	my $rslv = "/etc/resolv.conf";
	open (my $RSLV, "> $rslv") or &logdie("cannot open '$rslv' for writing: $!");
	printf $RSLV "search $domain\n";
	printf $RSLV "nameserver $net.$self\n";
	close $RSLV;

	# ensure it's readable!
	chmod 0644, $rslv;
	if (system("service $network_service restart >/dev/null 2>&1")) {
		&log ("cannot restart $network_service");
	} else {
		&log ("$network_service restarted successfully");
	}
}

sub print_network {
	if ($platform eq "fedora") {
		print_fedora_network;
	} else {
		print_debian_network;
	}
}

sub print_dhcp_conf {

	my $net = $settings{'net'};
	my $full_net = $net . "." . $settings{'net_start'};
	my $gw = $net . "." . $settings{'gateway'};
	my $self = $net . "." . $settings{'self-address'};
	my $dns1 = $net . "." . $settings{'self-address'};
	my $dyn_lo = $net . "." . $settings{'dyn_lo'};
	my $dyn_hi = $net . "." . $settings{'dyn_hi'};
	my $rev_net = &reverse_net ($net);
	my $time_offset = &get_time_offset();
	open(my $dhcpd, ">", $file_dhcpd);

	printf $dhcpd "ddns-update-style interim;\n";
	printf $dhcpd "do-forward-updates on;\n";
	printf $dhcpd "allow unknown-clients;\n";
	printf $dhcpd "ddns-updates on;\n";
        printf $dhcpd "ddns-domainname \"%s\";\n", $settings{'domain'};
        printf $dhcpd "ddns-rev-domainname \"in-addr.arpa\";\n";
	printf $dhcpd "ignore client-updates;\n";
	printf $dhcpd "allow bootp;\n";
	printf $dhcpd "allow booting;\n";
	printf $dhcpd "\n";
	printf $dhcpd "subnet %s netmask %s {\n", $full_net, $settings{'netmask'};
	printf $dhcpd "\tauthoritative;\n";
	printf $dhcpd "\toption routers %s;\n", $gw;
	printf $dhcpd "\toption subnet-mask %s;\n", $settings{'netmask'};
	printf $dhcpd "\toption domain-name \"%s\";\n", $settings{'domain'};
	if ($use_opendns_secondary) {
		printf $dhcpd "\toption domain-name-servers %s, %s;\n", $dns1, $settings{'external-dns1'};
	} else {
		printf $dhcpd "\toption domain-name-servers %s, %s;\n", $dns1, $dns1;
	}
	printf $dhcpd "\toption time-offset %s;\n", $time_offset;
	printf $dhcpd "\trange %s %s;\n", $dyn_lo, $dyn_hi;
	printf $dhcpd "\tdefault-lease-time %s;\n",$settings{'dhcp_lease_time'} || '14400';
	printf $dhcpd "\tmax-lease-time %s;\n",$settings{'dhcp_lease_time'} || '14400';
	printf $dhcpd "\tfilename \"pxelinux.0\";\n";
	printf $dhcpd "\tnext-server %s;\n", $self;
	printf $dhcpd "}\n\n";
        printf $dhcpd "key \"ddnskey\" {\n";
        printf $dhcpd "\talgorithm hmac-md5;\n";
        printf $dhcpd "\tsecret \"%s\";\n", "8zaPJsiw9tOh2JFv4xiArw==";
        printf $dhcpd "};\n\n";
	printf $dhcpd "zone %s. {\n", $settings{'domain'};
       	printf $dhcpd "\tprimary 127.0.0.1;\n";
       	printf $dhcpd "\tkey ddnskey;\n";
	printf $dhcpd "}\n\n";
	printf $dhcpd "zone %s. {\n", $rev_net;
       	printf $dhcpd "\tprimary 127.0.0.1;\n";
       	printf $dhcpd "\tkey ddnskey;\n";
	printf $dhcpd "}\n\n";

	&print_dhcp_conf_hosts ($dhcpd);

	close $dhcpd;
}


sub generate_files {

	&get_db_settings();
	&print_dhcp_conf ();
	&print_network ();
	&get_named_settings();
	&print_named_conf ();
	&print_domain_info ();
	&move_files();
}

sub basic_checks {
	my $ruid = $<;
	my $euid = $>;

	if ($euid != 0) {
		printf "ERROR: this program must be run as \"root\".\n";
		printf "Quitting ...\n";
		exit (1);
	}
	$platform = &get_platform();
	&log ("running on platform: $platform");
}

sub get_platform {
	open (my $file, "< /etc/issue") or return "unknown";
	my $p = <$file>;
	chomp $p;
	return "fedora" if ($p =~ /Fedora/);
	return "debian" if ($p =~ /Debian/);
	return "ubuntu" if ($p =~ /Ubuntu/);

	return "unknown";
}

### detach ourselves as a daemon

sub fork_daemon {

	my $pid = fork;
	if ($pid < 0) {
		print STDERR "${program}: can not fork ($!)\n";
		exit -1;
	} elsif ($pid) {
		# parent simply exit
		exit 0;
	}
	# chil continues execution
	$SIG{'CHLD'}   = 'DEFAULT';
	open(STDOUT, ">/dev/null");
	open(STDERR, ">/dev/null");
	open(STDIN,  "</dev/null");
	mkdir("/var/run/hda-ctl");

	&write_pid ();
}

sub unlink_files {
	unlink $pidfile;
}

sub write_pid {

	return unless ($pidfile);
	local *FD;
	if (! open(FD, "> $pidfile")) {
		&log ("Cannot create file '$pidfile'. ($!)");
	} else {
		printf FD "$$\n";
		close(FD);
	}
}

sub do_periodic_update {

	# NOTE - this is not needed (yet), since the API key
	# does not change. if other things are needed from the
	# DB, then this should be uncommented
	# &db_connect ();
	# &get_db_settings();

	my $api_key = $settings{'api-key'};
	if (!defined($api_key)) {
		# FIXME: deprecated, but some may still have it
		$api_key = $settings{'hda-id'};
	}
	my $os = &get_os_version();
	my $arch = &get_arch();
	my $url = "http://api-ddns.amahi.org/update?api_key=$api_key&os=$os&arch=$arch&ver=$version";
	# FIXME - need to resolve mysql locking issues first
	my $content = get($url);

	# &db_disconnect ();
}

sub do_periodic_action {
	&do_periodic_update();
}

sub check_service
{
	my $service = shift;

	my $sth = $dbh->prepare('SELECT start_at_boot from `servers` WHERE `name` = ?; ')
		or &logdie("Couldn't prepare statement: " . $dbh->errstr);
	$sth->execute($service);
	my @data = $sth->fetchrow_array();

	my $result = 1;
	if (@data) {
		$result = ($data[0] == 1);
		if ($result) {
			&log ("$service is enabled")
		} else {
			&log ("$service is disabled")
		}
	} else {
		# default to enabled, cause the service is not there!
		$result = 1;
		&log ("$service setting is not present - defaulting to enabled")
	}
	return $result;
}

sub restart_named {
	if (&check_service($named_service)) {
		if (system("service $named_service restart >/dev/null 2>&1")) {
			&log ("cannot restart $named_service");
		} else {
			&log ("$named_service restarted successfully");
		}
	} else {
		&log("named not enabled");	
	}
}

sub restart_network {

	my $g = get("http://www.yahoo.com");
	if (!defined($g)) {
		if (system("service $network_service restart >/dev/null 2>&1")) {
			&log ("cannot restart $network_service");
		} else {
			&log ("$network_service restarted successfully");
		}
	}
}

sub get_os_version {
	if (open (my $file, "< /etc/issue")) {
		my $f = <$file>;
		chomp $f;
		return uri_escape($f);
	}
	if (open (my $file, "< /etc/system-release")) {
		my $f = <$file>;
		chomp $f;
		return uri_escape($f);
	}
	return uri_escape("no-sys-release-file");
}

sub get_arch {
	if ($platform eq "fedora") {
		open (my $file, "uname -i |") or
			return uri_escape("cannot-run-uname-i");
		my $f = <$file>;
		chomp $f;
		return uri_escape($f);
	} else {
		open (my $file, "uname -m |") or
			return uri_escape("cannot-run-uname-m");
		my $f = <$file>;
		chomp $f;
		return uri_escape($f);
	}
}

sub restart_dhcpd {
	if(&check_service($dhcp_service)){
		if (system("service $dhcp_service stop >/dev/null 2>&1")) {
			&log ("cannot stop $dhcp_service");
		} else {
			&log ("$dhcp_service stopped successfully");
		}

		if (system("service $dhcp_service start >/dev/null 2>&1")) {
			&log ("cannot start $dhcp_service");
		} else {
			&log ("$dhcp_service started successfully");
		}
	} else {
		&log("$dhcp_service not enabled");
	}
}

sub do_hup_action {
	&log ("caught SIGHUP: executing programmed action.");

	&db_connect();
        &generate_files ();
	&restart_named ();
	&restart_dhcpd ();
	&db_disconnect ();

	&log ("services restarted");
}

sub dump_mode {
	$dump_mode = 1;
	&db_connect();
	&generate_files ();
	&db_disconnect();
	exit (0);
}

sub command_fifo_old {
	unless (-p $cmdfile) {
		unlink $cmdfile;
		my $prev_umask = umask 000;
		if (! mkfifo($cmdfile, 0666)) {
			&log("can’t mkfifo $cmdfile: $!");
			return -1;
		}
		umask $prev_umask;
	}

	while (1) {
		if (! open($CMDFIFO, "<", $cmdfile)) {
			last;
		}
		$CMDFIFO->autoflush(1);
		while (<$CMDFIFO>) {
			chomp;
			my $cmd = $_;
			# FIXME!!! - check that commands being run are valid!
			my $ret = system($cmd);
		}
		close ($CMDFIFO);
	}
	unlink $cmdfile;
	return 0;
}

sub command_fifo {

	if (! socket(SERV, PF_UNIX, SOCK_STREAM, 0)) {
		&log("can’t setup socket for $cmdfile: $!");
	}

	unlink $cmdfile;
	my $prev_umask = umask 000;
	if (! bind(SERV, sockaddr_un($cmdfile))) {
		&log("can’t bind with $cmdfile: $!");
		return -1;
	}
	umask $prev_umask;

	if (! listen(SERV, SOMAXCONN)) {
		&log("can’t listen on $cmdfile: $!");
		return -1;
	}

	&log("command fifo starting ...");
	while (!$caught_term) {
		# serve one at a time
		while (accept(CLIENT, SERV)) {
			CLIENT->autoflush(1);
			while (<CLIENT>) {
				if (/confirm: (.*)$/) {
					# write ack back if found
					print CLIENT $1;
					last;
				}
				chomp;
				my $cmd = $_;
				# FIXME!!! - check that commands being run are valid!
				my $ret = system($cmd);
			}
			close (CLIENT);
		}
		&log("WARNING: accept failed with: $!") unless $caught_term;
	}
	&log("caught SIGTERM: command fifo terminating.");
	unlink $cmdfile;
	return 0;
}

sub fork_command_fifo {

	my $pid = fork;
	if ($pid < 0) {
		print STDERR "${program}: can not fork ($!)\n";
		exit -1;
	} elsif ($pid) {
		# parent
		return $pid;
	}

	# this is the child process
	my $ret = &command_fifo();
	exit $ret;
	# if we return, it would go back to the parent process to
	# start the daemon!
}

sub usage {
	printf "usage: hda-ctl [-d]\n";
	printf "\t-d: dump files in current directory and exit\n";

	exit (0);
}

sub get_time_offset {
	my $wasnegative = 0;

	open TIME, "date +%z |" or &logdie("Failed to open pipe in get_time_offset: $!");
	my $time = <TIME>; 
	close TIME;

	if ($time < 0){
		$wasnegative = 1;
		$time *= -1;
	}
	$time =~ s/0//g;
	
	my $timeoffset = $time * 3600;

	if ($wasnegative){
		$timeoffset *= -1;
	}

	return $timeoffset;
}

sub set_platform_variables {
	if ($platform eq "fedora") {
		$named_user = "named";
		$named_service = "named";
		$named_dir = "/etc";
		$network_service = "network";
		$dhcp_service = "dhcpd";
	} else {
		$named_user = "bind";
		$named_service = "bind9";
		$named_dir = "/etc/bind";
		$network_service = "networking";
		$dhcp_service = "isc-dhcp-server";
	}
}

sub main {

	&usage() if (defined($opt_h));

        # first set platform and platform variables, these are needed by dump_mode
        $platform = &get_platform();
        &log ("running on platform: $platform");
        &set_platform_variables();

	# dump mode exits after it's done
	&dump_mode() if (defined($opt_d));

	&log ("starting hda-ctl v$version.");

	&basic_checks ();

	&fork_daemon ();
	my $command_processor_pid = &fork_command_fifo ();

	# FIXME - this will reset the settings from the DB at
	# every reboot
	&db_connect ();
	&generate_files ();
	&restart_named ();
	&restart_dhcpd ();
	&db_disconnect ();

	umask 022;
	do {
		$now = time;

		&do_periodic_action();

		my $left = $period;
		while (($left > 0) && !$caught_hup && !$caught_term && !$caught_usr1) {
			my $delay = $left > 5 ? 5 : $left;

			$0 = sprintf("%s - sleeping for %s seconds", $program, $left);
			$left -= sleep $delay;
		}
		unless ($caught_term) {
			if ($caught_hup) {
				&do_hup_action ();
				$caught_hup = 0;
			}
		}

	} while (!$caught_term);

	&log ("caught SIGTERM: exiting hda-ctl v$version.") if $caught_term;
	&unlink_files();
	kill('TERM', $command_processor_pid);

	exit -2;
}


&main ();

